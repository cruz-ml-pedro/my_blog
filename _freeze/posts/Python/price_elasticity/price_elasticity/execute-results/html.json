{
  "hash": "ec575f7b202d559bd08f7dd0e1583390",
  "result": {
    "markdown": "---\ntitle: Elasticidade de Preço\nsubtitle: Modelo Aditivo Generalizado\nauthor: Pedro Lima\ndate: '2023-11-07'\ncategories:\n  - Modelos Estatísticos\n  - Python\ntoc: true\ntoc-depth: 3\nformat:\n  html:\n    code-tools: false\n    code-fold: false\ndraft: true\n---\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom pygam import s, ExpectileGAM\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom IPython.core.display import display, HTML\n# Definir o tamanho padrão das imagens\ndisplay(HTML(\"<style>.rendered_html img {max-width:80%; height:auto;}</style>\"))\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<style>.rendered_html img {max-width:80%; height:auto;}</style>\n```\n:::\n:::\n\n\n# Criando os dados\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n#gerando os dados\nnp.random.seed(0)\nn=100\nprice = np.sort(np.random.exponential(scale=100,size=n))\nquantity = 1000 - 5 * price + np.random.normal(loc=0, scale=50,size=n)\nquantity = quantity.clip(min=0)\n```\n:::\n\n\nEsse trecho de código está criando dados simulados para as variáveis price e quantity com base em distribuições aleatórias. Vamos analisar linha por linha:\n\nnp.random.seed(0): Configura a semente para o gerador de números aleatórios do NumPy. Isso garante que os números aleatórios gerados sejam os mesmos em diferentes execuções do código, tornando os resultados reproduzíveis.\n\nn = 100: Define o tamanho da amostra como 100.\n\nprice = np.sort(np.random.exponential(scale=100, size=n)): Gera uma amostra de 100 valores a partir de uma distribuição exponencial com uma escala de 100. Em seguida, esses valores são ordenados em ordem crescente usando np.sort() e atribuídos à variável price.\n\nquantity = 1000 - 5 * price + np.random.normal(loc=0, scale=50, size=n): Gera valores para a variável quantity com base em uma relação linear com a variável price. Adiciona-se ruído normal à relação linear usando np.random.normal() com uma média (loc) de 0 e um desvio padrão (scale) de 50.\n\nquantity = quantity.clip(min=0): Substitui qualquer valor negativo em quantity por 0. Isso é feito usando o método clip(), garantindo que a quantidade não seja negativa.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n#adicionando outliers\nn_outliers = 10\noutliers_prices = np.random.uniform(5,50,n_outliers)\noutliers_quantity = 1100 +  np.random.normal(loc=0,scale=50,size=n_outliers)\nprice = np.concatenate([price, outliers_prices])\nquantity = np.concatenate([quantity, outliers_quantity])\n```\n:::\n\n\nEste trecho de código adiciona outliers aos dados simulados já gerados para as variáveis price e quantity. Vamos analisar linha por linha:\n\nn_outliers = 10: Define o número de outliers como 10.\n\noutliers_prices = np.random.uniform(5, 50, n_outliers): Gera 10 valores uniformemente distribuídos entre 5 e 50, representando os preços dos outliers.\n\noutliers_quantity = 1100 + np.random.normal(loc=0, scale=50, size=n_outliers): Gera 10 valores para as quantidades dos outliers, adicionando ruído normal à média de 1100, com um desvio padrão de 50.\n\nprice = np.concatenate([price, outliers_prices]): Concatena os valores de outliers_prices ao final da array price. Isso adiciona os outliers à variável price.\n\nquantity = np.concatenate([quantity, outliers_quantity]): Concatena os valores de outliers_quantity ao final da array quantity. Isso adiciona os outliers à variável quantity.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n#adicionando outliers\nn_outliers = 10\noutliers_prices = np.random.uniform(51,100,n_outliers)\noutliers_quantity = 900 +  np.random.normal(loc=0,scale=50,size=n_outliers)\nprice = np.concatenate([price, outliers_prices])\nquantity = np.concatenate([quantity, outliers_quantity])\n```\n:::\n\n\nNeste trecho de código, você está adicionando mais 10 outliers às variáveis price e quantity. Vamos analisar cada linha:\n\nn_outliers = 10: Define novamente o número de outliers como 10.\n\noutliers_prices = np.random.uniform(51, 100, n_outliers): Gera 10 valores uniformemente distribuídos entre 51 e 100, representando os preços dos novos outliers.\n\noutliers_quantity = 900 + np.random.normal(loc=0, scale=50, size=n_outliers): Gera 10 valores para as quantidades dos novos outliers, adicionando ruído normal à média de 900, com um desvio padrão de 50.\n\nprice = np.concatenate([price, outliers_prices]): Concatena os valores de outliers_prices ao final da array price. Isso adiciona os novos outliers à variável price.\n\nquantity = np.concatenate([quantity, outliers_quantity]): Concatena os valores de outliers_quantity ao final da array quantity. Isso adiciona os novos outliers à variável quantity.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndf = pd.DataFrame({\n  'Price' : price,\n  'Quantity': quantity\n})\n```\n:::\n\n\nEste trecho de código cria um DataFrame do Pandas chamado df a partir das variáveis price e quantity. Vamos entender cada parte:\n\n\n# filtrando \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndf = df[df['Price'] >= 5]\n```\n:::\n\n\n# cruiando o modelo\n\n## reshape data\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nx = df[['Price']]\ny = df['Quantity']\n```\n:::\n\n\n# GAMs quantile\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nquantiles = [0.025, 0.5, 0.975]\ngam_results = {}\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nfor q in quantiles:\n  gam = ExpectileGAM(s(0),expectile=q)\n  gam.fit(x,y)\n  gam_results[q] = gam\n  \n#gam_results\n```\n:::\n\n\n# Visualizando\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Scaterplot\nplt.figure(figsize=(8,6))\nplt.scatter(df['Price'], df['Quantity'], alpha=0.5, label='Data Points')\n\n  # plot quantile GAMs\n\nxx = np.linspace(df['Price'].min(), df['Price'].max(), 1000).reshape(-1,1)\n\nfor q, gam in gam_results.items():\n  plt.plot(xx, gam.predict(xx), label=f'{int(q*100)}th Quantile GAM')\n  \n#add title and labels\nplt.xlabel('Price')\nplt.ylabel('Quantity Demanded')\nplt.title('Quantile GAMs on Price Elasticity of Demand (Outliers Removed)')\nplt.legend()\nplt.grid(True, which='both',\nlinestyle='--', linewidth=0.5)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](price_elasticity_files/figure-html/cell-11-output-1.png){width=758 height=566}\n:::\n:::\n\n\n",
    "supporting": [
      "price_elasticity_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}