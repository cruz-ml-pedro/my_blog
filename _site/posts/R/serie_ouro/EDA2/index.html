<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pedro Lima">
<meta name="dcterms.date" content="2023-10-17">

<title>PeDrOOM Blog - Cotação do ouro - Parte 2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script src="../../../../site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="../../../../site_libs/lightable-0.0.1/lightable.css" rel="stylesheet">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">PeDrOOM Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../CV.html" rel="" target="">
 <span class="menu-text">Curriculum vitæ</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../blog.html" rel="" target="">
 <span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/cruz-ml-pedro" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/pedro-lima-8a9356268/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Cotação do ouro - Parte 2</h1>
            <p class="subtitle lead">Análise Exploratória - Parte 2</p>
                                <div class="quarto-categories">
                <div class="quarto-category">EDA</div>
                <div class="quarto-category">Série-Temporal</div>
                <div class="quarto-category">R</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Pedro Lima </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 17, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introdução" id="toc-introdução" class="nav-link active" data-scroll-target="#introdução">Introdução</a></li>
  <li><a href="#estacionariedade-dos-dados" id="toc-estacionariedade-dos-dados" class="nav-link" data-scroll-target="#estacionariedade-dos-dados">Estacionariedade dos Dados</a>
  <ul class="collapse">
  <li><a href="#adf" id="toc-adf" class="nav-link" data-scroll-target="#adf">Dickey-Fuller (ADF)</a></li>
  <li><a href="#kpss" id="toc-kpss" class="nav-link" data-scroll-target="#kpss">Kwiatkowski-Phillips-Schmidt-Shin (KPSS)</a></li>
  </ul></li>
  <li><a href="#transformando-os-dados" id="toc-transformando-os-dados" class="nav-link" data-scroll-target="#transformando-os-dados">Transformando os Dados</a>
  <ul class="collapse">
  <li><a href="#decomposição" id="toc-decomposição" class="nav-link" data-scroll-target="#decomposição">Decomposição</a></li>
  <li><a href="#box-cox" id="toc-box-cox" class="nav-link" data-scroll-target="#box-cox">Box Cox</a></li>
  <li><a href="#diferenciação" id="toc-diferenciação" class="nav-link" data-scroll-target="#diferenciação">Diferenciação</a></li>
  </ul></li>
  <li><a href="#funções-de-autocorrelações" id="toc-funções-de-autocorrelações" class="nav-link" data-scroll-target="#funções-de-autocorrelações">Funções de Autocorrelações</a>
  <ul class="collapse">
  <li><a href="#função-de-autocorrelação-acf" id="toc-função-de-autocorrelação-acf" class="nav-link" data-scroll-target="#função-de-autocorrelação-acf">Função de Autocorrelação (ACF)</a></li>
  <li><a href="#função-de-autocorrelação-parcial-pacf" id="toc-função-de-autocorrelação-parcial-pacf" class="nav-link" data-scroll-target="#função-de-autocorrelação-parcial-pacf">Função de Autocorrelação Parcial (PACF)</a></li>
  <li><a href="#algumas-aplicações" id="toc-algumas-aplicações" class="nav-link" data-scroll-target="#algumas-aplicações">Algumas Aplicações</a>
  <ul class="collapse">
  <li><a href="#dados-originais" id="toc-dados-originais" class="nav-link" data-scroll-target="#dados-originais">Dados Originais</a></li>
  <li><a href="#componente-remainder" id="toc-componente-remainder" class="nav-link" data-scroll-target="#componente-remainder">Componente ‘remainder’</a></li>
  <li><a href="#dados-sazonais" id="toc-dados-sazonais" class="nav-link" data-scroll-target="#dados-sazonais">Dados sazonais</a></li>
  <li><a href="#dados-diferenciados" id="toc-dados-diferenciados" class="nav-link" data-scroll-target="#dados-diferenciados">Dados Diferenciados</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#conclusão" id="toc-conclusão" class="nav-link" data-scroll-target="#conclusão">Conclusão</a></li>
  <li><a href="#referências" id="toc-referências" class="nav-link" data-scroll-target="#referências">Referências</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<div class="cell" data-hash="index_cache/html/unnamed-chunk-2_417379c2a3f06487b90172439f7f6fbb">
<style type="text/css">
.justify {
  text-align: justify;
}
</style>
</div>
<section id="introdução" class="level1">
<h1>Introdução</h1>
<div class="justify">
<p>Esta é a etapa final da análise exploratória dos dados da cotação do ouro. Para informações detalhadas sobre os dados, pacotes utilizados e o pré-processamento dos dados brutos, consulte a <a href="https://pedroom-blog.netlify.app/posts/serie_ouro/eda/">primeira parte</a> desta série. Os objetos que foram criados na postagem anterior e que serão empregados nesta publicação são “fit”, que contém os resultados do modelo STL, e “set_table”, uma função desenvolvida para a criação e formatação de tabelas.</p>
</div>
</section>
<section id="estacionariedade-dos-dados" class="level1">
<h1>Estacionariedade dos Dados</h1>
<div class="justify">
<p>A estacionariedade é um conceito fundamental na análise de séries temporais e processos estocásticos. Uma série temporal é considerada estacionária quando suas propriedades estatísticas, como a média e a variância, permanecem constantes ao longo do tempo. Isso implica que os padrões e as relações entre os dados não mudam com o tempo. A estacionariedade é crucial para muitas técnicas de modelagem e previsão, pois muitos métodos assumem que os dados exibem essa propriedade para produzir resultados precisos. Caso contrário, a falta de estacionariedade pode levar a resultados enganosos, uma vez que os padrões flutuantes nos dados podem obscurecer tendências reais e criar falsas correlações.</p>
<p>Conforme veremos adiante, existem testes estatísticos e técnicas de transformação disponíveis para avaliar e alcançar a estacionariedade em séries temporais, o que, por conseguinte, assegura uma base sólida para análises e previsões de alta precisão.</p>
<p>Para avaliar a estacionariedade dos dados serão utilizados o teste Dickey-Fuller Aumentado (<code>adf.test()</code>) e o teste de Kwiatkowski-Phillips-Schmidt-Shin (<code>unitroot_kpss</code>).</p>
</div>
<section id="adf" class="level2">
<h2 class="anchored" data-anchor-id="adf">Dickey-Fuller (ADF)</h2>
<div class="justify">
<p>O teste de Dickey-Fuller Aumentado (ADF, na sigla em inglês) é empregado para verificar a existência de raízes unitárias em séries temporais univariadas. A hipótese nula deste teste pressupõe a não estacionariedade; logo, se o valor-p do teste for inferior a um nível de significância especificado, temos base para rejeitar a hipótese nula e inferir que a série é estacionária.</p>
<p>A equação do teste ADF é dada por:</p>
<p><span class="math display">\[\Delta y_t = \alpha + \beta t + \gamma y_{t-1} + \delta_1 \Delta y_{t-1} + \delta_2 \Delta y_{t-2} + \ldots + \delta_p \Delta y_{t-p} + \varepsilon_t\]</span></p>
<p>onde:</p>
<ul>
<li><p><span class="math inline">\(\Delta y_t \text{ é a diferença entre } y_t \text{ e } y_{t-1}\)</span>,</p></li>
<li><p><span class="math inline">\(\alpha\)</span> é o termo constante,</p></li>
<li><p><span class="math inline">\(\beta\)</span> é o coeficiente da tendência temporal,</p></li>
<li><p><span class="math inline">\(\gamma\)</span> é o coeficiente de <span class="math inline">\(y_{t-1}\)</span>,</p></li>
<li><p><span class="math inline">\(\delta_1\)</span>, <span class="math inline">\(\delta_2\)</span>, <span class="math inline">\(\ldots\)</span>, <span class="math inline">\(\delta_p\)</span> são os coeficientes das diferenças defasadas de <span class="math inline">\(y_t\)</span>,</p></li>
<li><p><span class="math inline">\(\varepsilon_t\)</span> é o termo de erro.</p></li>
</ul>
<p>Para realizar o teste ADF, utilizaremos a função <code>adf.test</code> do pacote <code>tseries</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-7_a4170aa165313ef108cd2db1e70892fa">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>tseries<span class="sc">::</span><span class="fu">adf.test</span>(<span class="fu">ts</span>(fit<span class="sc">$</span>value),<span class="at">alternative =</span><span class="st">"stationary"</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Augmented Dickey-Fuller Test

data:  ts(fit$value)
Dickey-Fuller = -2.4719, Lag order = 5, p-value = 0.3803
alternative hypothesis: stationary</code></pre>
</div>
</div>
<p>O teste ADF não encontrou evidências que justifiquem a rejeição da hipótese nula de não estacionariedade.</p>
</div>
</section>
<section id="kpss" class="level2">
<h2 class="anchored" data-anchor-id="kpss">Kwiatkowski-Phillips-Schmidt-Shin (KPSS)</h2>
<div class="justify">
<p>O teste KPSS visa determinar se uma série temporal é estacionária em relação a uma tendência determinística, em contraposição à estacionariedade em torno de um valor médio constante. A hipótese nula do teste KPSS pressupõe que a série é estacionária. Portanto, se o valor-p obtido for superior ao nível de significância, não temos justificativa para rejeitar a hipótese nula, o que indica que a série é estacionária em relação a uma tendência. No entanto, se o valor-p for inferior ao nível de significância, podemos rejeitar a hipótese nula e concluir que a série não é estacionária em relação a uma tendência, implicando que a tendência é estocástica.</p>
<p>A estatística do teste KPSS é definida da seguinte forma:</p>
<p><span class="math display">\[KPSS = \frac{T^2 \cdot \hat{\sigma}^2}{\sum_{t=1}^{T} S_t^2}\]</span></p>
<p>Onde:</p>
<ul>
<li><p><span class="math inline">\(T\)</span> é o número de observações na série temporal.</p></li>
<li><p><span class="math inline">\(S_t\)</span> é a soma cumulativa das diferenças entre as observações e a estimativa da tendência local em cada ponto na série temporal. Calculado como: <span class="math display">\[S_t = \sum_{i=1}^{t} (X_i - \hat{m}_t)\]</span>.</p></li>
<li><p><span class="math inline">\(\hat{\sigma}^2\)</span> é uma estimativa da variância da série temporal.</p></li>
</ul>
<p>Onde <span class="math inline">\(X_i\)</span> é a observação no tempo <span class="math inline">\(i\)</span> e <span class="math inline">\(\hat{m}_t\)</span> é a estimativa da tendência local no tempo <span class="math inline">\(t\)</span>.</p>
<p>Para o teste KPSS será usado a função <code>unitroot_kpss</code> do pacote <code>fable</code>.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-8_2489486b4ee3ecfd5e099a593ce62f96">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">%&gt;%</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  fabletools<span class="sc">::</span><span class="fu">features</span>(value, unitroot_kpss) <span class="sc">%&gt;%</span> </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_tab</span>(<span class="st">"Teste KPSS"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="table-responsive">
<table class="table table-striped table-hover table-condensed table-sm small" data-quarto-postprocess="true">
<caption>Teste KPSS</caption>
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">.model</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">kpss_stat</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">kpss_pvalue</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">feasts::STL(value)</td>
<td style="text-align: right;">1.8768</td>
<td style="text-align: right;">0.01</td>
</tr>
</tbody>
</table>
</div>


</div>
</div>
<p>O teste kpss, apresenta evidência para rejeitar a hipótese nula, que nesse caso é de estacionariedade.</p>
<p>Os dois testes indicam a não estacionariedade dos dados, uma característica desfavorável que, em alguns casos, é essencial para certos tipos de modelos. A seguir examinaremos algumas das principais abordagens para transformar os dados em um estado estacionário.</p>
</div>
</section>
</section>
<section id="transformando-os-dados" class="level1">
<h1>Transformando os Dados</h1>
<div class="justify">
<p>Existem diversos métodos disponíveis para transformar séries temporais a fim de torná-las estacionárias. A seleção do método apropriado depende das características específicas da série temporal em questão e dos objetivos da análise ou modelagem em curso. Por vezes, é necessário experimentar vários métodos para identificar qual deles é o mais adequado para a situação.</p>
<p>Aqui estão alguns dos principais métodos de transformação:</p>
<ul>
<li><p>Diferenciação: A diferenciação é uma técnica simples, ela envolve subtrair cada valor na série pelo valor anterior. Se uma série temporal não for estacionária devido a uma tendência linear, uma diferenciação de primeira ordem geralmente é suficiente.</p></li>
<li><p>Diferenciação sazonal: Envolve subtrair o valor atual pelo valor do mesmo período sazonal anterior (por exemplo, o valor de um ano atrás, se a sazonalidade for anual).</p></li>
<li><p>Decomposição: A decomposição é uma técnica que separa uma série temporal em três componentes principais: tendência, sazonalidade e ruído. Uma vez separados, você pode remover a tendência e a sazonalidade, deixando apenas o componente de ruído estacionário.</p></li>
<li><p>Suavização exponencial: A suavização exponencial é uma técnica que suaviza os dados, removendo flutuações de curto prazo. Ela pode ser usada para tornar a série mais estável, especialmente se houver ruído aleatório significativo.</p></li>
<li><p>Box-Cox Transformation: A transformação Box-Cox é uma família de transformações paramétricas que inclui a transformação logarítmica como um caso especial. Ela é usada quando a variância dos dados não é constante ao longo do tempo. A transformação Box-Cox pode ajudar a estabilizar a variância dos dados.</p></li>
</ul>
<p>A seguir vou verificar a eficácia de três métodos aos dados da cotação do ouro: a decomposição, Box-Cox e diferenciação.</p>
</div>
<section id="decomposição" class="level2">
<h2 class="anchored" data-anchor-id="decomposição">Decomposição</h2>
<div class="justify">
<p>Após a decomposição dos dados, como discutido na <a href="https://pedroom-blog.netlify.app/posts/serie_ouro/eda/">primeira postagem</a> desta série, obtemos várias representações dos dados originais que capturam as estruturas identificadas. Neste ponto, estou examinando a componente ‘remainder’ do modelo STL, que, teoricamente, teve as componentes de tendência e de sazonalidade retiradas. Como mencionei anteriormente, essa componente exibe um comportamento espectral muito semelhante ao dos dados brutos, incluindo elementos cíclicos ou quase cíclicos.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-9_f5aab8fb1656b4531a0bc268e49c6fff">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="1440"></p>
</div>
</div>
<p>Vamos usar novamente o teste KPSS para verificar a estacionariedade dos dados.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-10_6600e63bcec8669aa91c37dd9a2c554f">
<div class="cell-output-display">
<div class="table-responsive">
<table class="table table-striped table-hover table-condensed table-sm small" data-quarto-postprocess="true">
<caption>Teste KPSS</caption>
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">.model</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">kpss_stat</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">kpss_pvalue</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">feasts::STL(value)</td>
<td style="text-align: right;">0.0361</td>
<td style="text-align: right;">0.1</td>
</tr>
</tbody>
</table>
</div>


</div>
</div>
<p>O teste não apresentou evidências que justificassem a rejeição da hipótese nula de estacionariedade, o que sugere que a abordagem foi eficaz em tornar os dados estacionários. No entanto, como indicado durante a análise espectral e teste Ljung-Box , esses dados não exibem um comportamento de ruído branco e podem conter estruturas significativas.</p>
</div>
</section>
<section id="box-cox" class="level2">
<h2 class="anchored" data-anchor-id="box-cox">Box Cox</h2>
<div class="justify">
<p>A transformação de Box-Cox é uma técnica estatística usada para estabilizar a variância e tornar uma distribuição mais próxima da normalidade. Ela é frequentemente aplicada em séries temporais ou outras análises estatísticas quando os dados exibem heteroscedasticidade (variação não constante) ou não seguem uma distribuição normal.</p>
<p>Sua forma geral pode ser definida matematicamente da seguinte maneira:</p>
<p>Para um conjunto de dados <span class="math inline">\((x_1, x_2, x_3, \ldots, x_n)\)</span> a transformação de Box-Cox é definida como:</p>
<p><span class="math display">\[y_i =
\begin{cases}
\frac{x_i^\lambda - 1}{\lambda}, &amp; \text{se } \lambda \neq 0 \\
\ln(x_i), &amp; \text{se } \lambda = 0
\end{cases}\]</span></p>
<p>Onde:</p>
<ul>
<li><p><span class="math inline">\(y_i\)</span> é o valor transformado do dado <span class="math inline">\(x_i\)</span></p></li>
<li><p>O parâmetro <span class="math inline">\(\lambda\)</span> é estimado através da função de verossimilhança e avaliação da adequação do modelo.</p></li>
</ul>
<p>Quando <span class="math inline">\(\lambda\)</span> é igual a zero, a transformação se torna uma transformação logarítmica natural (<span class="math inline">\(ln(x_i)\)</span>) Quando <span class="math inline">\(\lambda\)</span> não é igual a zero, a transformação é uma potência do dado original (<span class="math inline">\(x_i^\lambda\)</span>) com uma correção para garantir que a transformação seja bem definida para todos os valores de <span class="math inline">\(x_i\)</span>.</p>
<p>A escolha do valor ideal para λ é geralmente feita visando a maximização da normalidade dos dados transformados ou a estabilização da variância. Uma prática comum envolve testar vários valores dentro de um intervalo específico e aplicar a transformação a cada valor da série. Nessa tarefa, estou utilizando a função <code>forecast::BoxCox.lambda</code> do pacote <code>forecast</code>, que possibilita a seleção automática desse parâmetro. Essa função determina o valor de λ de modo a maximizar o perfil da verossimilhança logarítmica de um modelo linear ajustado aos dados. Para dados não sazonais, é ajustada uma tendência temporal linear, enquanto para dados sazonais, é usado um modelo linear de tendência temporal com variáveis sazonais dummy.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-11_2f1a220f21ed0d3db59dfcb0be2dd997">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>lambda <span class="ot">&lt;-</span> <span class="fu">round</span>(forecast<span class="sc">::</span><span class="fu">BoxCox.lambda</span>(fit<span class="sc">$</span>value), <span class="at">digits =</span> <span class="dv">2</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>lambda</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.38</code></pre>
</div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-12_7ed4ea2ad50a44de81420d1d53f7f112">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">%&gt;%</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">mutate</span>(<span class="at">box_cox_close =</span> fabletools<span class="sc">::</span><span class="fu">box_cox</span>(value, <span class="at">lambda=</span>lambda)) <span class="sc">%&gt;%</span> </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>   <span class="fu">ggplot</span>(<span class="fu">aes</span>(index,box_cox_close))<span class="sc">+</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>   <span class="fu">geom_line</span>()<span class="sc">+</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>   <span class="fu">ggtitle</span>(<span class="st">"Transformação Box Cox"</span>)<span class="sc">+</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>   <span class="fu">xlab</span>(<span class="st">""</span>)<span class="sc">+</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>   <span class="fu">ylab</span>(<span class="st">""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid" width="1440"></p>
</div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-13_f9bd4f6c8f4e0f1b97b9c1723036558c">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">%&gt;%</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">mutate</span>(<span class="at">box_cox_close =</span> fabletools<span class="sc">::</span><span class="fu">box_cox</span>(value, <span class="at">lambda=</span>lambda)) <span class="sc">%&gt;%</span> </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>   <span class="fu">features</span>(box_cox_close, unitroot_kpss) <span class="sc">%&gt;%</span> </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>   <span class="fu">set_tab</span>(<span class="st">"Teste KPSS"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="table-responsive">
<table class="table table-striped table-hover table-condensed table-sm small" data-quarto-postprocess="true">
<caption>Teste KPSS</caption>
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">.model</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">kpss_stat</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">kpss_pvalue</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">feasts::STL(value)</td>
<td style="text-align: right;">1.8652</td>
<td style="text-align: right;">0.01</td>
</tr>
</tbody>
</table>
</div>


</div>
</div>
<p>A transformação não modificou a forma dos dados, apenas o range de valores do eixo y. Entretanto, como o teste KPSS indicou isso não foi o suficiente para tornar os dados estacionários.</p>
</div>
</section>
<section id="diferenciação" class="level2">
<h2 class="anchored" data-anchor-id="diferenciação">Diferenciação</h2>
<div class="justify">
<p>A diferenciação em séries temporais é uma técnica amplamente empregada para converter dados não estacionários em um formato mais apropriado para análise e modelagem. Essa técnica consiste na subtração dos valores consecutivos na série temporal, com o propósito de eliminar estruturas de tendência e padrões sazonais. Ao aplicar a diferenciação, a série é transformada em uma nova série de diferenças, com a esperança de torná-la estacionária.</p>
<p>A remoção das estruturas mencionadas é geralmente alcançada por meio das diferenciações de primeira ordem e sazonal, e ou pela combinação e repetição dos procedimentos. A diferenciação de primeira ordem é realizada subtraindo o valor atual pelo valor anterior na série temporal e é eficaz na eliminação de tendências lineares nos dados. Por outro lado, a diferenciação sazonal envolve o cálculo das diferenças entre os valores da série no mesmo período, mas em anos diferentes, o que é útil para eliminar efeitos sazonais. Isso é realizado com o uso do “lag sazonal”, que representa o número de períodos em uma temporada. Por exemplo, se estiver lidando com dados mensais e a sazonalidade for anual, o lag sazonal seria igual a 12.</p>
<p>Está técnica pode ser descrita da seguinte forma:</p>
<p><span class="math display">\[\Delta y_t = y_t - y_{t-1}\]</span></p>
<p>Onde:</p>
<ul>
<li><span class="math inline">\(\Delta\)</span> representa a diferença entre o valor atual <span class="math inline">\(y_t\)</span> e o valor anterior <span class="math inline">\(y_{t-1}\)</span> na série tempora.</li>
</ul>
<p>Para se determinar o número de diferenças necessárias para tornar os dados estacionários usaremos a função <code>unitroot_ndiffs</code>, que tem com base o teste ADF, anteriormente explicado. Lembrando que o termo “unit root” (raiz unitária) se refere a uma característica de séries temporais não estacionárias. A presença de uma raiz unitária indica que a série não reverte rapidamente perturbações, tornando-a menos previsíveis e mais suscetíveis a flutuações, o que, de fato, pode tornar a análise e a modelagem mais desafiadoras.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-14_feca371a251ac93ad8137c25a917356c">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">%&gt;%</span> </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  fabletools<span class="sc">::</span><span class="fu">features</span>(value,  unitroot_ndiffs) <span class="sc">%&gt;%</span> </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_tab</span>(<span class="st">"Número de Diferenças"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="table-responsive">
<table class="table table-striped table-hover table-condensed table-sm small" data-quarto-postprocess="true">
<caption>Número de Diferenças</caption>
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">.model</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">ndiffs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">feasts::STL(value)</td>
<td style="text-align: right;">1</td>
</tr>
</tbody>
</table>
</div>


</div>
</div>
<p>O teste sinaliza a necessidade de realizar uma diferenciação para tornar a série estacionária.</p>
<div class="cell" data-hash="index_cache/html/grafico-diff_8280b2441d55e3ad927f78d1405ef06f">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">%&gt;%</span> </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">diff_close =</span> tsibble<span class="sc">::</span><span class="fu">difference</span>(value)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">%&gt;%</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(index,diff_close))<span class="sc">+</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>()<span class="sc">+</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggtitle</span>(<span class="st">"Dados diferenciados"</span>)<span class="sc">+</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">""</span>)<span class="sc">+</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">""</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/grafico-diff-1.png" class="img-fluid" width="1440"></p>
</div>
</div>
<p>Após a transformação dos dados, aparentemente, não parece haver nenhuma estrutura remanescente.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-15_3d1bd331381457058b0849790b128a29">
<div class="cell-output-display">
<div class="table-responsive">
<table class="table table-striped table-hover table-condensed table-sm small" data-quarto-postprocess="true">
<caption>Teste KPSS</caption>
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">.model</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">kpss_stat</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">kpss_pvalue</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">feasts::STL(value)</td>
<td style="text-align: right;">0.3244</td>
<td style="text-align: right;">0.1</td>
</tr>
</tbody>
</table>
</div>


</div>
</div>
<p>O teste KPSS apresenta evidências que sustentam a aceitação da hipótese nula de estacionariedade.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-16_d93d728b9375737960b1a44213648fb7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">%&gt;%</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">mutate</span>(</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">diff_close =</span> tsibble<span class="sc">::</span><span class="fu">difference</span>(value)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>     ) <span class="sc">%&gt;%</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  fabletools<span class="sc">::</span><span class="fu">features</span>(value, ljung_box, <span class="at">lag =</span> <span class="dv">78</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_tab</span>(<span class="st">"Teste LJUNG-BOX"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="table-responsive">
<table class="table table-striped table-hover table-condensed table-sm small" data-quarto-postprocess="true">
<caption>Teste LJUNG-BOX</caption>
<thead>
<tr class="header">
<th style="text-align: left;" data-quarto-table-cell-role="th">.model</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">lb_stat</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">lb_pvalue</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">feasts::STL(value)</td>
<td style="text-align: right;">2768.323</td>
<td style="text-align: right;">0</td>
</tr>
</tbody>
</table>
</div>


</div>
</div>
<p>O teste Ljung-Box indica que a série se comporta como um ruído branco, ou seja, não apresenta autocorrelação significativa.</p>
</div>
</section>
</section>
<section id="funções-de-autocorrelações" class="level1">
<h1>Funções de Autocorrelações</h1>
<div class="justify">
<p>A Função de Autocorrelação (ACF, do inglês Autocorrelation Function) e a Função de Autocorrelação Parcial (PACF, do inglês Partial Autocorrelation Function) são ferramentas amplamente utilizadas na análise de séries temporais. Elas desempenham um papel importante na exploração da estrutura de dependência entre as observações, o que, por sua vez, facilita a modelagem e previsão desses dados.</p>
<p>Aqui está uma breve descrição de como essas funções operam e de suas aplicações em várias situações, abrangendo a análise dos dados brutos, as componentes do modelo STL e os dados transformados. Para uma compreensão mais aprofundada, é recomendável consultar as referências mencionadas neste artigo e outras fontes pertinentes.</p>
</div>
<section id="função-de-autocorrelação-acf" class="level2">
<h2 class="anchored" data-anchor-id="função-de-autocorrelação-acf">Função de Autocorrelação (ACF)</h2>
<div class="justify">
<p>A ACF pode ser representada da seguinte forma:</p>
<p>Dada uma série temporal <span class="math inline">\({X_t}\)</span>, onde t representa o tempo, a autocorrelação para um atraso (lag) <span class="math inline">\(k\)</span> é calculada da seguinte maneira:</p>
<p><span class="math display">\[ρ(k) = Cov(X_t, X_{t-k}) / (σ(X_t) * σ(X_{t-k}))\]</span></p>
<p>Onde:</p>
<ul>
<li><p><span class="math inline">\(ρ(k)\)</span> é a autocorrelação para o atraso <span class="math inline">\(k\)</span>.</p></li>
<li><p><span class="math inline">\(Cov(X_t, X_{t-k})\)</span> é a covariância entre <span class="math inline">\(X_t\)</span> e <span class="math inline">\(X_{t-k}\)</span>, ou seja, a medida de como as observações estão relacionadas em <span class="math inline">\(t\)</span> e <span class="math inline">\(t-k\)</span>.</p></li>
<li><p><span class="math inline">\(σ(X_t)\)</span> é o desvio padrão de <span class="math inline">\(X_t\)</span>, que mede a variabilidade dos valores em <span class="math inline">\(t\)</span>.</p></li>
<li><p><span class="math inline">\(σ(X_{t-k})\)</span> é o desvio padrão de <span class="math inline">\(X_{t-k}\)</span>, que mede a variabilidade dos valores em <span class="math inline">\(t-k\)</span>.</p></li>
</ul>
<p>Em resumo, a autocorrelação para um determinado atraso <span class="math inline">\(k\)</span> é a covariância normalizada pela variabilidade (desvio padrão) das observações separadas por esse atraso. Ela varia de -1 a 1, onde valores próximos de 1 indicam forte correlação positiva, valores próximos de -1 indicam forte correlação negativa e valores próximos de 0 indicam ausência de correlação.</p>
</div>
</section>
<section id="função-de-autocorrelação-parcial-pacf" class="level2">
<h2 class="anchored" data-anchor-id="função-de-autocorrelação-parcial-pacf">Função de Autocorrelação Parcial (PACF)</h2>
<div class="justify">
<p>A PACF é calculada da seguinte maneira:</p>
<p>Suponha que temos uma série temporal <span class="math inline">\(x_t\)</span> para <span class="math inline">\(t = 1, 2, \ldots, N\)</span>. O PACF de atraso <span class="math inline">\(k\)</span> (<span class="math inline">\(PACF_k\)</span>) é definido como:</p>
<p><span class="math display">\[PACF_k = \frac{\gamma_{t,t-k} - \sum_{i=1}^{k-1} \phi_i \gamma_{t-k,t-k+i}}{1 - \sum_{i=1}^{k-1} \phi_i PACF_i}\]</span></p>
<p>onde:</p>
<ul>
<li><p><span class="math inline">\(\gamma_{t,t-k}\)</span> é a função de autocovariância entre <span class="math inline">\(x_t\)</span> e <span class="math inline">\(x_t-k\)</span>.</p></li>
<li><p><span class="math inline">\(\phi_i\)</span> são os coeficientes estimados de um modelo AR de ordem <span class="math inline">\(i\)</span>, onde <span class="math inline">\(i = 1, 2, \ldots, k-1\)</span></p></li>
</ul>
<p>A função PACF é calculada iterativamente, começando com <span class="math inline">\(k\)</span> = 1 e progredindo até o atraso máximo desejado. Ela mede a correlação entre uma observação em um determinado momento e observações em intervalos de tempo anteriores, removendo o efeito de observações em lags intermediários. Isso ajuda a identificar a estrutura de dependência direta, indicando o possível número de termos autorregressivos a serem incluídos em um modelo AR.</p>
</div>
</section>
<section id="algumas-aplicações" class="level2">
<h2 class="anchored" data-anchor-id="algumas-aplicações">Algumas Aplicações</h2>
<div class="justify">
<ul>
<li><p>Modelagem de Séries Temporais: A ACF e a PACF são usadas para identificar a ordem adequada (p, d, q) de modelos da fámilia ARIMA, onde “p” é a ordem do componente AR, “d” é a ordem da diferenciação e “q” é a ordem do componente MA. Lembrando que ACF é usada para evidência de MA(q) e suas sazonalidades e a PACF é usada para identificação de AR(p) e suas sazonalidades.</p></li>
<li><p>Identificação de Padrões: Além de sua aplicação em modelagem, a ACF e a PACF também são úteis para identificar padrões temporais nas séries temporais, como sazonalidades, e tendências.</p>
<ul>
<li><p>A presença de autocorrelação significativa em lags variados nas funções ACF pode sugerir a presença de tendência, e que a série não é estacionária.</p></li>
<li><p>Se houver sazonalidade, você geralmente verá picos significativos na ACF em múltiplos lags (intervalos de tempo) que correspondem aos períodos sazonais. Por exemplo, em uma série mensal com sazonalidade anual, você esperaria ver picos nas defasagens 12, 24, 36, etc.</p></li>
<li><p>O comportamento dos picos significativos pode ajudar a indentificar o tipo de sazonalidade (aditiva, multiplicativa) presente nos dados.</p></li>
</ul></li>
<li><p>Diagnóstico de Resíduos: Após ajustar um modelo a uma série temporal, a ACF e a PACF dos resíduos (diferença entre os valores observados e os valores previstos pelo modelo) podem ser usadas para verificar se há estrutura remanescente nos resíduos.</p></li>
</ul>
<p>Em resumo, ACF e PACF são ferramentas essenciais na análise de séries temporais, desempenhando um papel fundamental na identificação da estrutura de dependência temporal e na seleção dos parâmetros apropriados para a modelagem de modelos estatísticos.</p>
</div>
<section id="dados-originais" class="level3">
<h3 class="anchored" data-anchor-id="dados-originais">Dados Originais</h3>
<div class="justify">
<p>As funções ACF e PACF não são geralmente a primeira abordagem quando se suspeita que os dados não sejam estacionários, como neste caso. No entanto, para fins ilustrativos, vou usá-las nos dados brutos.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-17_c74be42e02f2ad868b8c8c1b96e22ef1">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>max_lag <span class="ot">&lt;-</span> <span class="fu">nrow</span>(fit)<span class="sc">-</span><span class="dv">1</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>acf_plot <span class="ot">&lt;-</span> </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">%&gt;%</span> </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  feasts<span class="sc">::</span><span class="fu">ACF</span>(value, <span class="at">lag_max =</span> max_lag) <span class="sc">%&gt;%</span> </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  feasts<span class="sc">::</span><span class="fu">autoplot</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-18_835e3384508c2c03a86be1f71f725110">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>pacf_plot <span class="ot">&lt;-</span> </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>fit <span class="sc">%&gt;%</span> </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  feasts<span class="sc">::</span><span class="fu">PACF</span>(value, <span class="at">lag_max =</span> max_lag) <span class="sc">%&gt;%</span> </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  feasts<span class="sc">::</span><span class="fu">autoplot</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-19_aca235400acba18c1894ca54d8159647">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ggpubr<span class="sc">::</span><span class="fu">ggarrange</span>(acf_plot,pacf_plot, <span class="at">ncol=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid" width="1440"></p>
</div>
</div>
<p>O Gráfico de ACF revela correlações significativas em lags próximos, com uma diminuição gradual que não se aproxima rapidamente de zero. Esse padrão sugere a presença de tendência nos dados, uma característica geralmente associada à não estacionariedade. A transição das correlações de positivas para negativas parece estar relacionada às mudanças no comportamento da tendência ao longo do tempo.</p>
<p>Por outro lado, os resultados da função PACF mostram valores significativos apenas nos lags 1 e 2, indicando que os efeitos observados no Gráfico de ACF podem ser atribuídos principalmente à presença de tendência nos dados.</p>
<p>Em uma série estacionária, é comum que os gráficos de ACF e PACF apresentem uma rápida diminuição após um pequeno número de defasagens, sem exibir padrões significativos. A ocorrência de padrões irregulares nesses gráficos sugere a possibilidade de ruído nos dados ou outros elementos não estacionários, corroborando assim os demais resultados das análises realizadas até o momento.</p>
</div>
</section>
<section id="componente-remainder" class="level3">
<h3 class="anchored" data-anchor-id="componente-remainder">Componente ‘remainder’</h3>
<div class="justify">
<p>Conforme já verificado, a componente ‘remainder’ demonstra estacionariedade de acordo com o teste KPSS, mas não exibe um comportamento de ruído branco conforme indicado pelo teste Ljung-Box. Isso pode ser atribuído, provavelmente, à presença de componentes cíclicas ou quase cíclicas.</p>
<p>Normalmente, as funções ACF e PACF são utilizadas em dados após a aplicação do operador de diferença. No entanto, a análise dos dados brutos, sem a componente de tendência, pode ser útil para ilustrar várias situações. Por exemplo, pode ajudar a melhorar a compreensão das estruturas cíclicas ou quase cíclicas nos dados. Em casos em que os dados brutos não exibem uma tendência intrínseca e já demonstram estacionariedade. Ou quando mesmo após a aplicação de diferenciação para torná-los estacionários, ainda podem persistir indícios de sazonalidade nos dados, e a estacionariedade pode não ser completamente alcançada.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-22_58507bf8a0887afbf935ab4d64aa3416">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid" width="1440"></p>
</div>
</div>
<p>Os picos positivos nos dois primeiros lags no gráfico de ACF sugerem uma forte correlação entre os valores no tempo atual e os valores no tempo imediatamente anterior. Essa observação pode ser indicativo de um componente <span class="math inline">\(MA(q)\)</span> em um modelo da família ARIMA.</p>
<p>Além disso, o gráfico mostra um comportamento senoidal, com picos significativos ou quase significativos em multiplos de cerca de 12 meses. Isso sugere a presença de um componente sazonal nas séries temporais. No entanto, é importante notar que o período não é bem definido, e os picos apresentam rápido decaimento e picos adicionais ao redor do período principal. Os valores dos picos na parte periódica são baixos (menores ou iguais a 0,5), o que pode indicar que a capacidade de previsão do componente sazonal pode ser limitada. A presença de picos negativos entre os picos positivos pode indicar algum tipo de efeito de amortecimento ou compensação nas séries temporais.</p>
<p>O decaimento e a quase significância de outros picos na ACF podem resultar em raízes do polinômio característico que estão muito próximas do ciclo unitário. indício que os processos autorregressivos ou de média móvel têm dificuldade em convergir, o que pode resultar em previsões imprecisas e modelos instáveis.</p>
<p>Para lidar com raízes próximas ao ciclo unitário em modelos ARIMA, é fundamental considerar alternativas, como a adoção de um modelo SARIMA (Seasonal ARIMA), a fim de eficazmente incorporar a sazonalidade e aprimorar a estabilidade das previsões. Além disso, é apropriado realizar uma diferenciação sazonal, com o período identificado, para tornar a série temporal mais estacionária. Recomenda-se, também, conduzir uma análise minuciosa dos resultados do modelo para assegurar sua adequação aos dados específicos em questão. Isso envolve a validação dos resíduos do modelo, que por sua vez requer o uso da ACF e PACF.</p>
<p>A PACF indica que há significância até a segunda repetição do ciclo de 12 meses. No entanto, a natureza exata desse comportamento não é clara, e os valores, com exceção do primeiro pico, são baixos. Em resumo, os dados apresentam um comportamento complexo e ruidoso, como já evidenciado em resultados anteriores.</p>
<p>Com base nas análises da ACF e PACF, é razoável suspeitar que um modelo SARIMA com termos <span class="math inline">\(MA(q)(Q)\)</span>, onde <span class="math inline">\(q=1, 2\)</span> e <span class="math inline">\(Q=1\)</span>, com uma componente sazonal de 12 meses, e <span class="math inline">\(AR(p)(P)\)</span> onde <span class="math inline">\(p=1, 2, 4, 5\)</span> e <span class="math inline">\(P=1\)</span> com a mesma componente sazonal de 12 meses, podem ser apropriados para modelar essa série temporal. No entanto, a escolha final do modelo SARIMA dependerá de testes de diagnóstico adicionais e validação cruzada para garantir a precisão das previsões e a adequação do modelo aos dados.</p>
</div>
</section>
<section id="dados-sazonais" class="level3">
<h3 class="anchored" data-anchor-id="dados-sazonais">Dados sazonais</h3>
<div class="justify">
<div class="cell" data-hash="index_cache/html/unnamed-chunk-25_87ec8640d1ee2051cf66be43741cb053">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-25-1.png" class="img-fluid" width="1440"></p>
</div>
</div>
<p>A componente ‘sazonal’ criada pelo modelo STL é livres de ruído, tornando mais simples a visualização do padrão cíclico presente neles. Comparando os resultados dos dados brutos com os atuais, observamos que tanto a ACF quanto a PACF são semelhantes, aparentemente o modelo STL emulou o comportamento periódico dos dados brutos, mas “corrigindo” os picos para os lags múltiplos de 12.</p>
<p>Em resumo, a análise dessa componente sazonal pode contribuir para uma identificação mais nítida do comportamento dos dados brutos através das caracteristicas da sazonalidade identificada pelo modelo STL ao construir essa componente.</p>
<p>Lembrando que existem dois tipos de sazonalidade, a aditiva e a multiplicativa. A sazonalidade aditiva inclui componentes <span class="math inline">\(AR(.)\)</span> e <span class="math inline">\(MA(.)\)</span> degenerados, o que resulta em picos de significância estatística isolados na ACF e PACF. Por outro lado, a sazonalidade multiplicativa causa significância não apenas no “coeficiente principal”, mas também em períodos próximos a ele, como ilustrado no exemplo atual.</p>
<p>A PACF mostra significância até a primeira repetição do ciclo de 12 meses. É bastante provável que esse <span class="math inline">\(AR(p)(1)_{12}\)</span> seja invertível e esteja causando o <span class="math inline">\(MA(q)(Q)_{12}\)</span> com alta persistência nos lags múltiplos de 12, como indicado na ACF.</p>
</div>
</section>
<section id="dados-diferenciados" class="level3">
<h3 class="anchored" data-anchor-id="dados-diferenciados">Dados Diferenciados</h3>
<div class="justify">
<p>Como mencionado <a href="../../../../posts/R/serie_ouro/EDA2/index.html#diferenciação">anteriormente</a>, uma diferenciação foi suficiente para tornar os dados estacionários, e agora eles exibem um comportamento semelhante ao de um ruído branco, como indicado pelo teste de Box-Cox. Em um contexto de modelagem ARIMA, uma vez que a estacionariedade é alcançada, o próximo passo é aplicar as funções de autocorrelação e autocorrelação parcial para determinar os parâmetros do modelo.</p>
<p>Além disso, esse comportamento é um indicativo de que a tendência pode ser de natureza aditiva.</p>
<div class="cell" data-hash="index_cache/html/unnamed-chunk-28_0e81f7ab524f2f032cd74d6093c8c382">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-28-1.png" class="img-fluid" width="1440"></p>
</div>
</div>
<p>Quando os gráficos ACF e PACF apresentam resultados significativos apenas no lag 1, isso geralmente indica uma estrutura de série temporal simples e sugere que os valores da série temporal estão fortemente correlacionados apenas com seus valores imediatamente anteriores, um indicativo comum de que um modelo autorregressivo de primeira ordem, AR(1), pode ser apropriado para modelar os dados.</p>
<p>Portanto, neste cenário podemos começar considerando um modelo ARIMA com <span class="math inline">\(p=1\)</span> (ordem autoregressiva) e d=1 (uma diferenciação).</p>
<p>No entanto, é importante notar que essa é apenas uma primeira aproximação na escolha dos parâmetros do modelo ARIMA. A seleção final dos parâmetros geralmente envolve tentativa e erro, além de critérios de seleção de modelos, como AIC (Akaike Information Criterion) ou BIC (Bayesian Information Criterion), para escolher o modelo que melhor se ajusta aos dados.</p>
</div>
</section>
</section>
</section>
<section id="conclusão" class="level1">
<h1>Conclusão</h1>
<div class="justify">
<p>Nesta segunda parte da análise exploratória, abordamos os seguintes tópicos: a questão da estacionariedade dos dados, algumas das técnicas empregadas para corrigir ou atenuar os efeitos da não estacionariedade nos dados e, por fim, exploramos o uso das funções de autocorrelação e autocorrelação parcial como ferramentas adicionais para identificar e caracterizar as estruturas subjacentes nos dados.</p>
<p>Por meio dos testes <a href="../../../../posts/R/serie_ouro/EDA2/index.html#adf">ADF</a> e <a href="../../../../posts/R/serie_ouro/EDA2/index.html#kpss">KPSS</a> foi verificado que os dados não possuem estacionariedade, confirmando os indícios observados nos gráficos dos dados brutos. Vale ressaltar que existem outros testes com a mesma finalidade.</p>
<p>Dentre as abordagens empregadas para tornar os dados estacionários, apenas a transformação de Box-Cox não se mostrou eficaz. No entanto, a escolha da transformação adequada depende das características dos dados e do modelo que será atulizado. É importante lembrar que após a modelagem, é necessário reverter a transformação para realizar previsões na escala original dos dados.</p>
<p>A utilização das funções ACF e PACF se destacou como uma abordagem mais relevante na identificação de parâmetros potenciais em modelos ARIMA (Média Móvel Integrada de AutoRegressão) e ETS (Erro, Tendência, Sazonalidade) em comparação com outras técnicas empregadas, que se mostraram mais eficazes na detecção de estruturas intrínsecas nos dados. Vale ressaltar que essa perspectiva reflete apenas minha opinião pessoal em relação às técnicas empregadas.</p>
<p>Os pontos mais relevantes identificados durante esta análise exploratória, em relação à modelagem são:</p>
<ul>
<li><p>Os dados podem ser desagregados em tendência, sazonalidade e resíduo, conforme sugerido pelo modelo STL.</p></li>
<li><p>As componentes periódicas identificadas nas análises espectrais exibem um comportamento complexo que varia ao longo do tempo, corroborando a indicação observada nos gráficos de sazonalidade e gráficos de ACF e PACF.</p></li>
<li><p>A utilização de uma única diferença para tornar os dados estacionários e aparência dos dados após a transformação, apresentando flutuações aproximadamente constantes, indica a utilização de uma tendência aditiva.</p></li>
<li><p>Os gráficos de ACF e PACF da componente ‘remainder’ do modelo STL reforçam a presença de estruturas periódica/quase periódica. Além disso os resultados apontam para a utilização de sazonalidade multiplicativa nos modelos.</p></li>
</ul>
<p>Na próxima postagem, iniciarei a construção dos modelos preditivos, começando com os modelos “clássicos” e, posteriormente, os modelos de IA.</p>
</div>
</section>
<section id="referências" class="level1">
<h1>Referências</h1>
<div class="justify">
<p><a href="https://pt.wikipedia.org/wiki/Autocorrela%C3%A7%C3%A3o">Autocorrelação</a></p>
<p><a href="https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test">Augmented Dickey–Fuller test</a></p>
<p><a href="https://www.rdocumentation.org/packages/forecast/versions/8.21.1/topics/BoxCox.lambda">BoxCox.lambda: Automatic selection of Box Cox transformation parameter</a></p>
<p><a href="https://rpubs.com/hudsonchavs/fac_facp">Correlação, Autocorrelação e Autocorrelação Parcial</a></p>
<p><a href="https://pt.wikipedia.org/wiki/Correla%C3%A7%C3%A3o_parcial">Correlação parcial</a></p>
<p><a href="https://www.rdocumentation.org/packages/tseries/versions/0.10-54/topics/adf.test">adf.test: Augmented Dickey-Fuller Test</a></p>
<p><a href="https://otexts.com/fpp3/decomposition.html">Forecasting: Principles and Practice (3rd ed)/Chapter 4 Time series features</a></p>
<p><a href="https://en.wikipedia.org/wiki/KPSS_test">KPSS test</a></p>
<p><a href="https://en.wikipedia.org/wiki/Power_transform">Power transform</a></p>
<p><a href="https://www.rdocumentation.org/packages/tsfeatures/versions/1.1/topics/unitroot_kpss">unitroot_kpss: Unit Root Test Statistics</a></p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>